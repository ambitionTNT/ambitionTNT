4、多线程

4.1、什么是进程？什么是线程？
	进程是一个应用程序。
	线程是进程的执行场景/执行单元。
	一个进程可以启动多个线程。
4.2、对于java程序来说，当在DOS命令窗口中输入：
	java HelloWorld
 回车之后。
 会先启动JVM，而JVM就是一个进程。
 JVM再启动一个主线程调用main方法。
 同时再启动一个垃圾回收线程负责看护，回收垃圾。
 最起码，现在的java程序中至少有两个线程并发，一个是垃圾回收线程
 一个是执行main方法的主线程。
4.3、进程和线程是什么关系。
	进程
	是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。
	线程：
	是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。


区别：
地址空间
线程共享本进程的地址空间，而进程之间是独立的地址空间，同时线程之间共享方法区和堆区内存，而栈区内存独立。
资源
线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。

（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.
（4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
关系
（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。
（3）处理机分给线程，即真正在处理机上运行的是线程。
（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体

    4.5、分析一个问题：对于单核的CPU来说，真的可以做到真正的多线程并发吗？
 
        对于多核的CPU电脑来说，真正的多线程并发是没问题的。
            4核CPU表示同一个时间点上，可以真正的有4个进程并发执行。
 
        什么是真正的多线程并发？
            t1线程执行t1的。
            t2线程执行t2的。
            t1不会影响t2，t2也不会影响t1。这叫做真正的多线程并发。
 
        单核的CPU表示只有一个大脑：
            不能够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。
            对于单核的CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于
            CPU的处理速度极快，多个线程之间频繁切换执行，跟人来的感觉是：多个事情
            同时在做！！！！！
                线程A：播放音乐
                线程B：运行魔兽游戏
                线程A和线程B频繁切换执行，人类会感觉音乐一直在播放，游戏一直在运行，
                给我们的感觉是同时并发的。
         
        电影院采用胶卷播放电影，一个胶卷一个胶卷播放速度达到一定程度之后，
        人类的眼睛产生了错觉，感觉是动画的。这说明人类的反应速度很慢，就像
        一根钢针扎到手上，到最终感觉到疼，这个过程是需要“很长的”时间的，在
        这个期间计算机可以进行亿万次的循环。所以计算机的执行速度很快。

并行是指两个或者多个事件在同一时刻发生，而并发是指两个或多个事件在同一时间间隔发生。

并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。

5、java语言中，实现线程有两种方式。
	1、编写一个类，直接继承java.lang.Thread,重写run方法。run方法中的代码就会按照多线程机制进行调用和执行
	在main方法中定义类的对象，调用start()方法启动线程，会自动调用run方法
	        // 定义线程类
        public class MyThread extends Thread{
            public void run(){
             
            }
        }
        // 创建线程对象
        MyThread t = new MyThread();
        // 启动线程。
        t.start();
  2、 第二种方式：创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。
  在main方法中实例化Runnable接口的实现类对象;
  定义两个线程Thread类的对象，把Runnable接口的实现对象传入构造方法中;
  线程类对象调用start方法，启动线程，自动执行Runnable接口的实现类中的run 方法; 
	然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。
	每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称。 
	3.run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。
	 而start()的作用是启动相应的线程。启动一个线程实际是请求Java虚拟机运行相应的线程，
		而这个线程何时能够运行是由线程调度器决定的。start()调用结束并不表示相应线程已经开始运行，
		这个线程可能稍后运行，也可能永远也不会运行。

  1、怎么获取当前线程对象？
    Thread t = Thread.currentThread();
    返回值t就是当前线程。

2、获取线程对象的名字
    String name = 线程对象.getName();

3、修改线程对象的名字
    线程对象.setName("线程名字");

4、当线程没有设置名字的时候，默认的名字有什么规律？（了解一下）
    Thread-0
    Thread-1
    Thread-2
    Thread-3


    线程的阻塞状态：sleep方法
    在指定的毫秒数内让当前”正在执行“的线程休眠（暂停执行），
    此操作受到系统计时器和调度程序精度和准确性的影响。该线程不丢失任何监视器的所属权。 
	
  参数：
   millis - 以毫秒为单位的休眠时间。 
   Thread.sleep() 可以进行使代码间隔一段时间才执行。
	

	interrupt()
   //中断thread线程的睡眠(这种方式采用了异常处理机制)
        thread.interrupt();
	测试当前线程是否已经中断。线程的中断状态 由该方法清除。
	换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，
	且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。


常见的线程调度模型有哪些？
 
        抢占式调度模型：
            那个线程的优先级比较高，抢到的CPU时间片的概率就高一些/多一些。
            java采用的就是抢占式调度模型。
 
        均分式调度模型：
            平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。
            平均分配，一切平等。
            有一些编程语言，线程调度模型采用的是这种方式。
     
    1.2、java中提供了哪些方法是和线程调度有关系的呢？
 
        实例方法：
            void setPriority(int newPriority) 设置线程的优先级
            int getPriority() 获取线程优先级
            最低优先级1
            默认优先级是5
            最高优先级10
            优先级比较高的获取CPU时间片可能会多一些。（但也不完全是，大概率是多的。）
         
        静态方法：
            static void yield()  让位方法
            暂停当前正在执行的线程对象，并执行其他线程
            yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。
            yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。
            注意：在回到就绪之后，有可能还会再次抢到。
         
        实例方法：
	join() 的作用：让主线程”等待“子线程”结束之后才能继续运行。即主线程等待子线程的终止
            void join()  
            合并线程
            class MyThread1 extends Thread {
                public void doSome(){
                    MyThread2 t = new MyThread2();
                    t.join(); // 当前线程进入阻塞，t线程执行，直到t线程结束。当前线程才可以继续。
                }
            }
 
            谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，
	    并且这种线程并不属于程序中不可或缺的部分。
	    因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。
                 
同步：
并发进程在一些关键点上可能需要互相等待或互通消息，
这种相互制约的等待或互通消息称为进程同步。
同步机制应遵循的准则
空闲让进 ：其他进程均不处于临界区；
忙则等待 ：已有进程处于其临界区；
有限等待 ：等待进入临界区的进程不能"死等"；
异步性就是描述进程这种以不可预知的速度走走停停、何时开始何时暂停何时结束不可预知的性质。 
也就是说，如果传统意义上的程序没有在操作系统中为之配备进程控制块（PCB），
没有用它来描述进程基本情况和活动过程，
进而控制和管理进程，这样就会使程序在并发执行的时候失去其封闭性，也失去了可再现性。


        线程同步机制的语法是：
            synchronized(){
                // 线程同步代码块。
            }
            synchronized后面小括号中传的这个“数据”是相当关键的。
            这个数据必须是多线程共享的数据。才能达到多线程排队。

            ()中写什么？
                那要看你想让哪些线程同步。
                假设t1、t2、t3、t4、t5，有5个线程，
                你只希望t1 t2 t3排队，t4 t5不需要排队。怎么办？
                你一定要在()中写一个t1 t2 t3共享的对象。而这个
                对象对于t4 t5来说不是共享的。

            这里的共享对象是：账户对象。
            账户对象是共享的，那么this就是账户对象吧！！！
            不一定是this，这里只要是多线程共享的那个对象就行。

            在java语言中，任何一个对象都有“一把锁”，其实这把锁就是标记。（只是把它叫做锁。）
            100个对象，100把锁。1个对象1把锁。

            以下代码的执行原理？
                1、假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后。
                2、假设t1先执行了，遇到了synchronized，这个时候自动找“后面共享对象”的对象锁，
                找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一直都是
                占有这把锁的。直到同步代码块代码结束，这把锁才会释放。
                3、假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面
                共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面等待t1的结束，
                直到t1把同步代码块执行结束了，t1会归还这把锁，此时t2终于等到这把锁，然后
                t2占有这把锁之后，进入同步代码块执行程序。

                这样就达到了线程排队执行。
                这里需要注意的是：这个共享对象一定要选好了。这个共享对象一定是你需要排队
                执行的这些线程对象所共享的。

		
2、关于多线程并发环境下，数据的安全问题。
 
    2.1、为什么这个是重点？
        以后在开发中，我们的项目都是运行在服务器当中，
        而服务器已经将线程的定义，线程对象的创建，线程
        的启动等，都已经实现完了。这些代码我们都不需要
        编写。
 
        最重要的是：你要知道，你编写的程序需要放到一个
        多线程的环境下运行，你更需要关注的是这些数据
        在多线程并发的环境下是否是安全的。（重点：*****）
     
    2.2、什么时候数据在多线程并发的环境下会存在安全问题呢？
        三个条件：
            条件1：多线程并发。
            条件2：有共享数据。
            条件3：共享数据有修改的行为。
 
        满足以上3个条件之后，就会存在线程安全问题。
     
    2.3、怎么解决线程安全问题呢？
        当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在
        线程安全问题，怎么解决这个问题？
            线程排队执行。（不能并发）。
            用排队执行解决线程安全问题。
            这种机制被称为：线程同步机制。
 
            专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行。
         
        怎么解决线程安全问题呀？
            使用“线程同步机制”。
         
        线程同步就是线程排队了，线程排队了就会牺牲一部分效率，没办法，数据安全
        第一位，只有数据安全了，我们才可以谈效率。数据不安全，没有效率的事儿。
     
    2.4、说到线程同步这块，涉及到这两个专业术语：
 
        异步编程模型：
            线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，
            谁也不需要等谁，这种编程模型叫做：异步编程模型。
            其实就是：多线程并发（效率较高。）
 
            异步就是并发。
 
        同步编程模型：
            线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行
            结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，
            两个线程之间发生了等待关系，这就是同步编程模型。
            效率较低。线程排队执行。
 
            同步就是排队。
 
3、Java中有三大变量？【重要的内容。】
 
    实例变量：在堆中。
 
    静态变量：在方法区。
 
    局部变量：在栈中。
 
    以上三大变量中：
        局部变量永远都不会存在线程安全问题。
        因为局部变量不共享。（一个线程一个栈。）
        局部变量在栈中。所以局部变量永远都不会共享。
     
    实例变量在堆中，堆只有1个。
    静态变量在方法区中，方法区只有1个。
    堆和方法区都是多线程共享的，所以可能存在线程安全问题。
 
    局部变量+常量：不会有线程安全问题。
    成员变量：可能会有线程安全问题。

在实例方法上可以使用synchronized吗？
   答：可以的。synchronized出现在实例方法上，一定锁的是this.
   没得挑。只能是this。不能是其他的对象了。
   所以这种方法不灵活。

   另外还有一个缺点:synchronized出现在实例方法上，表示整个方法都是需要同步的，可能会
   无故扩大同步的范围，导致程序的执行效率降低。所以这种方式不常用。

   优点：代码简洁了。
   


  总结synchronized:
  
  第一种：同步代码代码块
	灵活
	synchronized(线程共享对象){
		同步代码块
	}
  第二种：在实例方法上使用synchronized
	表示共享对象一定是this。
	并且同步代码块是整个方法体。
  
  第三种：在静态方法上使用synchronized
         表示找类锁。
	 类锁永远只有1把
	 就算创建了 100个对象，类锁也只有一把

	 对象锁，是一个对象一把锁。


死锁：

死锁是指两个或两个以上的进程在执行过程中，
由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

6、聊一聊，我们以后开发中应该怎么解决线程安全问题？
 
    是一上来就选择线程同步吗？synchronized
        不是，synchronized会让程序的执行效率降低，用户体验不好。
        系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择
        线程同步机制。
     
    第一种方案：尽量使用局部变量代替“实例变量和静态变量”。
 
    第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样
    实例变量的内存就不共享了。（一个线程对应1个对象，100个线程对应100个对象，
    对象不共享，就没有数据安全问题了。）
 
    第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候
    就只能选择synchronized了。线程同步机制。
 
7、线程这块还有那些内容呢？列举一下
    7.1、守护线程
    7.2、定时器
    7.3、实现线程的第三种方式：FutureTask方式，实现Callable接口。（JDK8新特性。）
    7.4、关于Object类中的wait和notify方法。（生产者和消费者模式！）

1、线程这块还有那些内容呢？列举一下
 
    1.1、守护线程
 
        java语言中线程分为两大类：
            一类是：用户线程
            一类是：守护线程（后台线程）
            其中具有代表性的就是：垃圾回收线程（守护线程）。
 
        守护线程的特点：
            一般守护线程是一个死循环，所有的用户线程只要结束，
            守护线程自动结束。
         
        注意：主线程main方法是一个用户线程。
 
        守护线程用在什么地方呢？
            每天00:00的时候系统数据自动备份。
            这个需要使用到定时器，并且我们可以将定时器设置为守护线程。
            一直在那里看着，没到00:00的时候就备份一次。所有的用户线程
            如果结束了，守护线程自动退出，没有必要进行数据备份了。
 1.2、定时器
        定时器的作用：
            间隔特定的时间，执行特定的程序。
 
            每周要进行银行账户的总账操作。
            每天要进行数据的备份操作。
 
            在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，
            那么在java中其实可以采用多种方式实现：
                 
                可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行
                任务。这种方式是最原始的定时器。（比较low）
 
                在java的类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。
                不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持
                定时任务的。
 
                在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，
                这个框架只要进行简单的配置，就可以完成定时器的任

 void schedule(TimerTask task, Date time) 
          安排在指定的时间执行指定的任务。 
 void schedule(TimerTask task, Date firstTime, long period) 
          安排指定的任务在指定的时间开始进行重复的固定延迟执行。 
 void schedule(TimerTask task, long delay) 
          安排在指定延迟后执行指定的任务。 
 void schedule(TimerTask task, long delay, long period) 
          安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。 

Timer()  创建一个新计时器。 
Timer(boolean isDaemon) 
          创建一个新计时器，可以指定其相关的线程作为守护程序运行。 
Timer(String name) 
          创建一个新计时器，其相关的线程具有指定的名称。 
Timer(String name, boolean isDaemon) 
          创建一个新计时器，其相关的线程具有指定的名称，并且可以指定作为守护程序运行。 

1.3、实现线程的第三种方式：实现Callable接口。（JDK8新特性。）
这种方式实现的线程可以获取线程的返回值。
之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void。

思考：
    系统委派一个线程去执行一个任务，该线程执行完任务之后，可能
    会有一个执行结果，我们怎么能拿到这个执行结果呢？
	使用第三种方式：实现Callable接口方式。


1.4、关于Object类中的wait和notify方法。（生产者和消费者模式！）

第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象
都有的方法，因为这两个方式是Object类中自带的。
    wait方法和notify方法不是通过线程对象调用，
    不是这样的：t.wait()，也不是这样的：t.notify()..不对。
 
第二：wait()方法作用？
    Object o = new Object();
    o.wait();

    表示：
	让正在o对象上活动的线程进入等待状态，无期限等待，
	直到被唤醒为止。
	o.wait();方法的调用，会让“当前线程（正在o对象上
	活动的线程）”进入等待状态。

第三：notify()方法作用？
    Object o = new Object();
    o.notify();

    表示：
	唤醒正在o对象上等待的线程。
     
    还有一个notifyAll()方法：
	这个方法是唤醒o对象上处于等待的所有线程。





可运行线程
	static void yield() 使当前正在执行的线程想另一个线程家畜运行权。

阻塞和等待
	
	使用Thread.sleep,Obejct.join ,Lock.tryLock以及Condition.await
终止线程:
	stop可以杀死一个线程。该方法抛出一个ThreadDeath错误对象，这会杀死线程。
	void join() 等待终止指定的线程
	void join() 等待终止指定的线程

	Thread.State getState()
		得到线程的状态 NEW RUNNABKLE、BLOCKED\WAITING\TIMED_WAITING或者TERMINATED
	

线程数学




