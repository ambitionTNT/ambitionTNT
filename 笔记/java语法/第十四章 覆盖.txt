覆盖：
	什么时候我们会考虑使用“方法覆盖”呢？
	子类继承父类之后，当继承过来的方法无法满足子类的业务需求时，
	子类有权利对这个方法进行重新编写，有必要进行“方法的覆盖”。
方法覆盖又叫做：方法重写，英语单词叫做Override\Overwrite，都可以。
比较常见的：方法覆盖、方法重写、。
回顾一下方法重载：
	什么是侯考虑使用方法重载overload？
	当在一个类当中，如果功能相似的话，建议四将名字定义为一样的，这样
	代码美观，并且方便编程。
什么条件满足之后能够从方法重载：
	条件一：在同一个类中
	条件二：方法名相同
	条件三：参数列表不同

重要结论，如果方法名相同，子类会覆盖父类的
方法，子类对象调用该方法时，会执行自己的方法。
方法覆盖的条件：
  条件1：两个类必须要有继承的关系。
  条件2：重写之后的方法和之前的方法具有：
		相同的返回值类型
		相同的方法名
		相同的形式参数列表
  条件3：访问权限不能更低，可以更高。
  条件4：重写之后的方法不能比之前的方法抛出更多的异常，可以更少。


注意事项：
   1、方法覆盖只是针对于方法，和属性无关。
   2、私有方法无法覆盖。
   3、构造方法不能被继承，所以构造方法也不能被覆盖。
   4、方法覆盖只是针对于实例方法，静态方法没有意义。


       2.3、关于Object类中toString()方法的覆盖？
        toString()方法存在的作用就是：将java对象转换成字符串形式。
        大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()
        方法输出的是一个java对象的内存地址。
 
        至于toString()方法具体怎么进行覆盖？
            格式可以自己定义，或者听需求的。（听项目要求的。）

方法重载和方法覆盖有什么区别？
方法重载发生在同一个类当中。
方法覆盖是发生在具有继承关系的父子类之间。

方法重载是一个类中，方法名相同，参数列表不同。
方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致。
	方法名一致，参数列表一致，返回值类型一致。



多态：

1、两个概念：
	向上转向
	子类--->父类（自动类型转换）
	向下转向
	父类--->子类（强制类型转换，需要加强制类型转换符 ）
   注意：java中允许向上转向，也允许向下转性。
	无论哪种转向，两者类型之间必须有继承关系，没有继承关系编译器报错。
	又被称为强制类型转换：Cat c = (Cat)a; 需要添加强制类型转换符。
            什么时候需要向下转型？
                需要调用或者执行子类对象中特有的方法。
                必须进行向下转型，才可以调用。
            向下转型有风险吗？
                容易出现ClassCastException（类型转换异常）
            怎么避免这个风险？
                instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象
                是否为某一种类型。
                养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。
         
        不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。



day17课堂笔记
 
1、继承extends
     
    1.1、测试：子类继承父类之后，能使用子类对象调用父类方法吗？
        可以，因为子类继承了父类之后，这个方法就属于子类了。
        当然可以使用子类对象来调用。
 
    1.2、在实际开发中，满足什么条件的时候，我可以使用继承呢？
        凡是采用“is a”能描述的，都可以继承。
        例如：
            Cat is a Animal：猫是一个动物
            Dog is a Animal：狗是一个动物
            CreditAccount is a Account：信用卡账户是一个银行账户
            ....
         
        假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，
        那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够
        使用is a来描述。
 
            class Customer{
                String name; // 名字
                // setter and getter
            }
 
            class Product{
                String name; // 名字
                // setter and getter
            }
 
            class Product extends Customer{
             
            }
 
            以上的继承就属于很失败的。因为：Product is a Customer，是有违伦理的。
 
    1.3、任何一个类，没有显示继承任何类，默认继承Object，那么Object类当中有
    哪些方法呢？老祖宗为我们提供了哪些方法？
 
        以后慢慢的大家一定要适应看JDK的源代码（多看看牛人写的程序自己才会变成牛人。）
        先模仿后超越。
        java为什么比较好学呢？
            是因为Java内置了一套庞大的类库，程序员不需要从0开始写代码，程序员可以
            基于这套庞大的类库进行“二次”开发。（开发速度较快，因为JDK内置的这套库
            实现了很多基础的功能。）
 
            例如：String是SUN编写的字符串类、System是SUN编写的系统类。
            这些类都可以拿来直接使用。
         
        JDK源代码在什么位置？
            C:\Program Files\Java\jdk-13.0.2\lib\src.zip
         
        你现在能看懂以下代码了吗？
            System.out.println("Hello World!");
            System.out 中，out后面没有小括号，说明out是变量名。
            另外System是一个类名，直接使用类名System.out，说明out是一个静态变量。
            System.out 返回一个对象，然后采用“对象.”的方式访问println()方法。
         
        我们研究了一下Object类当中有很多方法，大部分看不懂，其中有一个叫做toString()
        的，我们进行了测试，发现：
            System.out.println(引用);
            当直接输出一个“引用”的时候，println()方法会先自动调用“引用.toString()”，然后
            输出toString()方法的执行结果。
         
2、方法覆盖
     
    2.1、什么时候考虑使用方法覆盖？
        父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。
 
    2.2、什么条件满足的时候构成方法覆盖？
        第一：有继承关系的两个类
        第二：具有相同方法名、返回值类型、形式参数列表
        第三：访问权限不能更低。
        第四：抛出异常不能更多。
 
    2.3、关于Object类中toString()方法的覆盖？
        toString()方法存在的作用就是：将java对象转换成字符串形式。
        大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()
        方法输出的是一个java对象的内存地址。
 
        至于toString()方法具体怎么进行覆盖？
            格式可以自己定义，或者听需求的。（听项目要求的。）
 
    2.4、方法重载和方法覆盖有什么区别？
 
        方法重载发生在同一个类当中。
 
        方法覆盖是发生在具有继承关系的父子类之间。
 
        方法重载是一个类中，方法名相同，参数列表不同。
 
        方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：
            方法名一致、参数列表一致、返回值类型一致。
 
3、多态的基础语法
     
    3.1、向上转型和向下转型的概念。
 
        向上转型：子--->父 (upcasting)
            又被称为自动类型转换：Animal a = new Cat();
 
        向下转型：父--->子 (downcasting)
            又被称为强制类型转换：Cat c = (Cat)a; 需要添加强制类型转换符。
            什么时候需要向下转型？
                需要调用或者执行子类对象中特有的方法。
                必须进行向下转型，才可以调用。
            向下转型有风险吗？
                容易出现ClassCastException（类型转换异常）
            怎么避免这个风险？
                instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象
                是否为某一种类型。
                养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。
         
        不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。
 
    3.2、什么是多态。
        多种形态，多种状态，编译和运行有两个不同的状态。
        编译期叫做静态绑定。
        运行期叫做动态绑定。
        Animal a = new Cat();
        // 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法
        // 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关
        // 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。
        a.move();
 
        多态的典型代码：父类型的引用指向子类型的对象。（java中允许这样写代码！！！）
 
    3.3、什么时候必须进行向下转型？
        调用子类对象上特有的方法时。